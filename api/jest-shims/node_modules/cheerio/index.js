const SELF_CLOSING = new Set(['img', 'br', 'hr', 'meta', 'link', 'input']);

const parseAttributes = (input) => {
  const attributes = {};
  const attributePattern = /([\w-:]+)(?:="([^"]*)")?/g;
  let match;

  while ((match = attributePattern.exec(input)) !== null) {
    const [, name, value] = match;
    attributes[name] = value ?? '';
  }

  return attributes;
};

const parseHtml = (html) => {
  const root = { tag: 'root', attributes: {}, children: [], text: '' };
  const stack = [root];
  const tokenPattern = /<[^>]+>|[^<]+/g;
  let match;

  while ((match = tokenPattern.exec(html)) !== null) {
    const token = match[0];

    if (token.startsWith('<')) {
      const isClosing = token.startsWith('</');
      const isSelfClosing = token.endsWith('/>');
      const tagContent = token
        .replace(/^</, '')
        .replace(/\/>$/, '')
        .replace(/>$/, '')
        .trim();

      if (isClosing) {
        stack.pop();
        continue;
      }

      const [tagNameRaw, ...attrParts] = tagContent.split(/\s+/);
      const tagName = tagNameRaw.toLowerCase();
      const attributes = parseAttributes(attrParts.join(' '));
      const node = { tag: tagName, attributes, children: [], text: '' };

      stack[stack.length - 1].children.push(node);

      if (!isSelfClosing && !SELF_CLOSING.has(tagName)) {
        stack.push(node);
      }
    } else {
      const text = token.replace(/\s+/g, ' ').trim();

      if (!text) {
        continue;
      }

      stack[stack.length - 1].children.push({
        tag: '#text',
        attributes: {},
        children: [],
        text,
      });
    }
  }

  return root;
};

const parseSelector = (selector) => {
  const trimmed = selector.trim();
  const tagMatch = trimmed.match(/^[a-zA-Z0-9-]+/);
  const tag = tagMatch ? tagMatch[0].toLowerCase() : null;
  const attributes = [];
  const attributePattern = /\[([^=\]]+)(?:="([^"]*)")?\]/g;
  let match;

  while ((match = attributePattern.exec(trimmed)) !== null) {
    const [, name, value] = match;
    attributes.push({ name, value: value ?? null });
  }

  return { tag, attributes };
};

const matchesSelector = (node, descriptor) => {
  if (node.tag === '#text') {
    return false;
  }

  if (descriptor.tag && node.tag !== descriptor.tag) {
    return false;
  }

  return descriptor.attributes.every(({ name, value }) => {
    if (!(name in node.attributes)) {
      return false;
    }

    return value === null || node.attributes[name] === value;
  });
};

const findMatches = (nodes, selector) => {
  const descriptor = parseSelector(selector);
  const result = [];

  const visit = (node) => {
    if (matchesSelector(node, descriptor)) {
      result.push(node);
    }

    for (const child of node.children) {
      visit(child);
    }
  };

  for (const node of nodes) {
    visit(node);
  }

  return result;
};

class Collection {
  constructor(nodes) {
    this.nodes = nodes;
    this.length = nodes.length;
  }

  attr(name) {
    return this.nodes[0]?.attributes[name];
  }

  text() {
    const collect = (node) => {
      if (node.tag === '#text') {
        return node.text;
      }

      return node.children.map((child) => collect(child)).join(' ');
    };

    return this.nodes.map((node) => collect(node)).join(' ').trim();
  }

  find(selector) {
    const nested = [];

    for (const node of this.nodes) {
      nested.push(...findMatches(node.children, selector));
    }

    return new Collection(nested);
  }

  first() {
    return new Collection(this.nodes.length > 0 ? [this.nodes[0]] : []);
  }

  each(callback) {
    this.nodes.forEach((node, index) => callback(index, node));
  }

  get(index) {
    return this.nodes[index];
  }
}

const createApi = (html) => {
  const root = parseHtml(html);

  const api = (input) => {
    if (typeof input === 'string') {
      return new Collection(findMatches(root.children, input));
    }

    return new Collection(input ? [input] : []);
  };

  api.root = () => new Collection(root.children);

  return api;
};

module.exports = { load: createApi };
