// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum CommentSource {
  TASK
  WATCHLIST
}

enum WatchlistStatus {
  ACTIVE
  PAUSED
  STOPPED
}

enum TelegramChatType {
  PRIVATE
  GROUP
  SUPERGROUP
  CHANNEL
}

enum TelegramMemberStatus {
  CREATOR
  ADMINISTRATOR
  MEMBER
  RESTRICTED
  LEFT
  KICKED
}

enum SuspicionLevel {
  NONE
  LOW
  MEDIUM
  HIGH
}

model Task {
  id             Int      @id @default(autoincrement())
  title          String
  description    String?
  completed      Boolean  @default(false)
  totalItems     Int      @default(0)
  processedItems Int      @default(0)
  progress       Float    @default(0)
  status         String   @default("pending")
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@index([status, createdAt(sort: Desc)]) // для выборки активных задач с сортировкой
  @@index([createdAt(sort: Desc)]) // для списка задач
  @@index([completed]) // для фильтрации завершенных
}

model TaskAutomationSettings {
  id        Int      @id @default(autoincrement())
  enabled   Boolean  @default(false)
  runHour   Int      @default(3)
  runMinute Int      @default(0)
  postLimit Int      @default(10)
  timezoneOffsetMinutes Int @default(0)
  lastRunAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Group {
  id           Int      @id @default(autoincrement())
  vkId         Int      @unique
  name         String
  screenName   String?
  isClosed     Int?
  deactivated  String?
  type         String?
  photo50      String?
  photo100     String?
  photo200     String?
  activity     String?
  ageLimits    Int?
  description  String?  @db.Text
  membersCount Int?
  status       String?
  verified     Int?
  wall         Int?
  addresses    Json?
  city         Json?
  counters     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  posts        Post[]

  @@index([wall]) // для поиска групп с enabled/disabled wall
  @@index([membersCount(sort: Desc)]) // для сортировки по популярности
}

model Post {
  id                    Int       @id @default(autoincrement())
  ownerId               Int
  vkPostId              Int
  fromId                Int
  postedAt              DateTime
  text                  String    @db.Text
  commentsCount         Int
  commentsCanPost       Int
  commentsGroupsCanPost Boolean
  commentsCanClose      Boolean
  commentsCanOpen       Boolean
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt
  groupId               Int?
  group                 Group?    @relation(fields: [groupId], references: [id], onDelete: SetNull)
  comments              Comment[]

  @@unique([ownerId, vkPostId])
  @@index([groupId, postedAt(sort: Desc)]) // для выборки постов группы
  @@index([postedAt(sort: Desc)]) // для сортировки по времени
  @@index([ownerId]) // для поиска по владельцу
}

model Comment {
  id                Int              @id @default(autoincrement())
  postId            Int
  ownerId           Int
  vkCommentId       Int
  fromId            Int
  text              String           @db.Text
  publishedAt       DateTime
  likesCount        Int?
  parentsStack      Json?
  threadCount       Int?
  threadItems       Json?
  attachments       Json?
  replyToUser       Int?
  replyToComment    Int?
  authorVkId        Int?
  author            Author?          @relation(fields: [authorVkId], references: [vkUserId], onDelete: SetNull)
  isDeleted         Boolean          @default(false)
  isRead            Boolean          @default(false)
  source            CommentSource    @default(TASK)
  watchlistAuthorId Int?
  watchlistAuthor   WatchlistAuthor? @relation(fields: [watchlistAuthorId], references: [id], onDelete: SetNull)
  watchlistSource   WatchlistAuthor? @relation("WatchlistSourceComment")
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  post              Post             @relation(fields: [ownerId, postId], references: [ownerId, vkPostId], onDelete: Cascade)
  commentKeywordMatches CommentKeywordMatch[]

  @@unique([ownerId, vkCommentId])
  @@index([postId])
  @@index([authorVkId])
  @@index([watchlistAuthorId])
  @@index([publishedAt(sort: Desc)]) // для сортировки по времени публикации
  @@index([source]) // для фильтрации TASK/WATCHLIST
  @@index([isRead]) // для фильтра прочитанных
  @@index([postId, authorVkId]) // для поиска комментариев автора в посте
  @@index([authorVkId, publishedAt(sort: Desc)]) // для истории активности автора
  @@index([watchlistAuthorId, publishedAt(sort: Desc)]) // для комментариев watchlist
}

model Listing {
  id            Int      @id @default(autoincrement())
  source        String?
  externalId    String?
  title         String?
  description   String?  @db.Text
  url           String   @unique
  price         Int?
  currency      String?
  address       String?
  city          String?
  latitude      Float?
  longitude     Float?
  rooms         Int?
  areaTotal     Float?
  areaLiving    Float?
  areaKitchen   Float?
  floor         Int?
  floorsTotal   Int?
  publishedAt   DateTime?
  contactName   String?
  contactPhone  String?
  images        String[] @default([])
  sourceAuthorName String?
  sourceAuthorPhone String?
  sourceAuthorUrl String?
  sourcePostedAt String? @db.Text
  sourceParsedAt DateTime?
  manualOverrides Json? @default("[]")
  manualNote    String?  @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([city])
  @@index([price])
}

model Author {
  id               Int               @id @default(autoincrement())
  vkUserId         Int               @unique
  firstName        String
  lastName         String
  deactivated      String?
  domain           String?
  screenName       String?
  isClosed         Boolean?
  canAccessClosed  Boolean?
  photo50          String?
  photo100         String?
  photo200         String?
  photo200Orig     String?
  photo400Orig     String?
  photoMax         String?
  photoMaxOrig     String?
  photoId          String?
  city             Json?
  country          Json?
  about            String?
  activities       String?
  bdate            String?
  books            String?
  career           Json?
  connections      Json?
  contacts         Json?
  counters         Json?
  education        Json?
  followersCount   Int?
  homeTown         String?
  interests        String?
  lastSeen         Json?
  maidenName       String?
  military         Json?
  movies           String?
  music            String?
  nickname         String?
  occupation       Json?
  personal         Json?
  relatives        Json?
  relation         Int?
  schools          Json?
  sex              Int?
  site             String?
  status           String?
  timezone         Int?
  tv               String?
  universities     Json?
  comments         Comment[]
  watchlistAuthors WatchlistAuthor[]
  photoAnalyses    PhotoAnalysis[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  verifiedAt       DateTime?

  @@index([firstName, lastName]) // для поиска по имени
  @@index([screenName]) // для поиска по никнейму
  @@index([domain]) // для поиска по домену
}

model PhotoAnalysis {
  id             Int            @id @default(autoincrement())
  authorId       Int
  author         Author         @relation(fields: [authorId], references: [id], onDelete: Cascade)
  photoUrl       String
  photoVkId      String
  analysisResult String         @db.Text
  hasSuspicious  Boolean        @default(false)
  suspicionLevel SuspicionLevel @default(NONE)
  categories     String[]
  confidence     Float?
  explanation    String?        @db.Text
  analyzedAt     DateTime       @default(now())
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@unique([authorId, photoVkId])
  @@index([authorId, hasSuspicious])
  @@index([suspicionLevel])
  @@index([analyzedAt(sort: Desc)])
}

model Keyword {
  id        Int      @id @default(autoincrement())
  word      String   @unique
  category  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  commentKeywordMatches CommentKeywordMatch[]
}

model CommentKeywordMatch {
  commentId Int
  keywordId Int
  createdAt DateTime @default(now())

  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  keyword Keyword @relation(fields: [keywordId], references: [id], onDelete: Cascade)

  @@id([commentId, keywordId])
  @@index([keywordId])
  @@index([commentId])
}

model WatchlistSettings {
  id                  Int               @id @default(autoincrement())
  trackAllComments    Boolean           @default(false)
  pollIntervalMinutes Int               @default(5)
  maxAuthors          Int               @default(50)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  authors             WatchlistAuthor[]
}

model WatchlistAuthor {
  id                  Int               @id @default(autoincrement())
  authorVkId          Int
  sourceCommentId     Int?              @unique
  status              WatchlistStatus   @default(ACTIVE)
  lastCheckedAt       DateTime?
  lastActivityAt      DateTime?
  foundCommentsCount  Int               @default(0)
  monitoringStartedAt DateTime          @default(now())
  monitoringStoppedAt DateTime?
  settingsId          Int
  settings            WatchlistSettings @relation(fields: [settingsId], references: [id], onDelete: Cascade)
  author              Author            @relation(fields: [authorVkId], references: [vkUserId], onDelete: Cascade)
  sourceComment       Comment?          @relation("WatchlistSourceComment", fields: [sourceCommentId], references: [id], onDelete: SetNull)
  comments            Comment[]
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@unique([authorVkId, settingsId])
  @@index([status])
  @@index([settingsId])
}

model TelegramChat {
  id          Int               @id @default(autoincrement())
  telegramId  BigInt            @unique
  type        TelegramChatType
  title       String?
  username    String?
  photoUrl    String?
  description String?           @db.Text
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  members     TelegramChatMember[]

  @@index([type])
  @@index([username])
}

model TelegramUser {
  id           Int               @id @default(autoincrement())
  telegramId   BigInt            @unique
  firstName    String?
  lastName     String?
  username     String?
  phoneNumber  String?
  bio          String?           @db.Text
  languageCode String?
  isBot        Boolean           @default(false)
  isPremium    Boolean           @default(false)
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  memberships  TelegramChatMember[]

  @@index([username])
  @@index([isBot])
}

model TelegramChatMember {
  id              Int                  @id @default(autoincrement())
  chatId          Int
  userId          Int
  status          TelegramMemberStatus
  isAdmin         Boolean              @default(false)
  isOwner         Boolean              @default(false)
  joinedAt        DateTime?
  leftAt          DateTime?
  importedAt      DateTime             @default(now())
  rawPayload      Json?
  chat            TelegramChat         @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user            TelegramUser         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([userId])
  @@index([status])
}
