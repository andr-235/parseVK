name: Deploy to Production Server

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Debian Server
    runs-on: [self-hosted, production]
    timeout-minutes: 45
    permissions:
      contents: read

    steps:
      - name: Checkout code
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Log deployment info
        run: |
          START_TIME=$(date +%s)
          echo "START_TIME=$START_TIME" >> $GITHUB_ENV
          echo "=== Deployment Information ==="
          echo "Commit: $(git rev-parse --short HEAD)"
          echo "Branch: $(git rev-parse --abbrev-ref HEAD)"
          echo "Author: $(git log -1 --pretty=format:'%an <%ae>')"
          echo "Message: $(git log -1 --pretty=format:'%s')"
          echo "Date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"

      - name: Check environment
        id: env_check
        timeout-minutes: 2
        run: |
          STEP_START=$(date +%s)
          echo "=== Environment Check ==="
          echo "User: $(whoami)"
          echo "Working directory: $(pwd)"
          
          DOCKER_VERSION=$(docker --version 2>/dev/null || echo "not installed")
          COMPOSE_VERSION=$(docker compose version 2>/dev/null || echo "not installed")
          
          if [ "$DOCKER_VERSION" = "not installed" ]; then
            echo "Error: Docker is not installed"
            exit 1
          fi
          
          if [ "$COMPOSE_VERSION" = "not installed" ]; then
            echo "Error: Docker Compose is not installed"
            exit 1
          fi
          
          echo "Docker version: $DOCKER_VERSION"
          echo "Docker Compose version: $COMPOSE_VERSION"
          
          MIN_DOCKER_VERSION="20.10"
          MIN_COMPOSE_VERSION="2.0"
          
          DOCKER_VER_NUM=$(echo "$DOCKER_VERSION" | grep -oE '[0-9]+\.[0-9]+' | head -1)
          COMPOSE_VER_NUM=$(echo "$COMPOSE_VERSION" | grep -oE '[0-9]+\.[0-9]+' | head -1)
          
          if [ -n "$DOCKER_VER_NUM" ] && [ "$(printf '%s\n' "$MIN_DOCKER_VERSION" "$DOCKER_VER_NUM" | sort -V | head -1)" != "$MIN_DOCKER_VERSION" ]; then
            echo "Warning: Docker version $DOCKER_VER_NUM is below recommended $MIN_DOCKER_VERSION"
          fi
          
          if [ -n "$COMPOSE_VER_NUM" ] && [ "$(printf '%s\n' "$MIN_COMPOSE_VERSION" "$COMPOSE_VER_NUM" | sort -V | head -1)" != "$MIN_COMPOSE_VERSION" ]; then
            echo "Warning: Docker Compose version $COMPOSE_VER_NUM is below recommended $MIN_COMPOSE_VERSION"
          fi
          
          AVAILABLE_SPACE=$(df -BG /opt 2>/dev/null | tail -1 | awk '{print $4}' | sed 's/G//')
          if [ -n "$AVAILABLE_SPACE" ] && [ "$AVAILABLE_SPACE" -lt 10 ]; then
            echo "Error: Insufficient disk space. Available: ${AVAILABLE_SPACE}GB, required: at least 10GB"
            exit 1
          fi
          echo "Available disk space: ${AVAILABLE_SPACE}GB"
          
          if [ ! -d "/opt/parseVK" ]; then
            echo "Error: /opt/parseVK directory does not exist"
            exit 1
          fi
          
          if [ ! -d "/opt/parseVK/.git" ]; then
            echo "Error: /opt/parseVK is not a git repository"
            exit 1
          fi
          
          STEP_END=$(date +%s)
          echo "Environment check completed in $((STEP_END - STEP_START))s"

      - name: Validate docker-compose
        id: validate_compose
        working-directory: /opt/parseVK
        timeout-minutes: 1
        run: |
          STEP_START=$(date +%s)
          if [ ! -f "docker-compose.yml" ]; then
            echo "Error: docker-compose.yml not found"
            exit 1
          fi
          if ! docker compose config > /dev/null 2>&1; then
            echo "Error: Invalid docker-compose.yml"
            docker compose config
            exit 1
          fi
          STEP_END=$(date +%s)
          echo "Docker compose validation completed in $((STEP_END - STEP_START))s"

      - name: Save current version for rollback
        id: save_version
        working-directory: /opt/parseVK
        run: |
          STEP_START=$(date +%s)
          if ! git rev-parse --git-dir > /dev/null 2>&1; then
            echo "Error: Not a valid git repository"
            exit 1
          fi
          
          CURRENT_COMMIT=$(git rev-parse HEAD 2>/dev/null)
          if [ -z "$CURRENT_COMMIT" ] || [ "$CURRENT_COMMIT" = "HEAD" ]; then
            CURRENT_COMMIT=$(git rev-parse origin/main 2>/dev/null || echo "unknown")
          fi
          
          echo "current_commit=$CURRENT_COMMIT" >> $GITHUB_OUTPUT
          echo "Saved current commit: $CURRENT_COMMIT"
          STEP_END=$(date +%s)
          echo "Version save completed in $((STEP_END - STEP_START))s"

      - name: Check port availability
        id: check_ports
        timeout-minutes: 1
        run: |
          STEP_START=$(date +%s)
          echo "=== Checking port availability ==="
          
          PORT_ERROR=0
          
          check_port() {
            local port=$1
            local service=$2
            local is_critical=${3:-false}
            
            if command -v netstat > /dev/null 2>&1; then
              if netstat -tuln 2>/dev/null | grep -q ":$port "; then
                if [ "$is_critical" = "true" ]; then
                  echo "Error: Port $port ($service) is already in use and is critical"
                  PORT_ERROR=1
                  return 1
                else
                  echo "Warning: Port $port is already in use (may be from previous deployment)"
                  return 0
                fi
              fi
            elif command -v ss > /dev/null 2>&1; then
              if ss -tuln 2>/dev/null | grep -q ":$port "; then
                if [ "$is_critical" = "true" ]; then
                  echo "Error: Port $port ($service) is already in use and is critical"
                  PORT_ERROR=1
                  return 1
                else
                  echo "Warning: Port $port is already in use (may be from previous deployment)"
                  return 0
                fi
              fi
            fi
            echo "Port $port ($service) is available"
            return 0
          }
          
          check_port 3000 "API" true
          check_port 8080 "Frontend" true
          
          if [ $PORT_ERROR -eq 1 ]; then
            echo "Error: Critical ports are in use. Please stop conflicting services."
            exit 1
          fi
          
          STEP_END=$(date +%s)
          echo "Port check completed in $((STEP_END - STEP_START))s"

      - name: Update code
        id: update_code
        working-directory: /opt/parseVK
        timeout-minutes: 5
        run: |
          STEP_START=$(date +%s)
          echo "=== Updating code ==="
          
          if ! git remote get-url origin > /dev/null 2>&1; then
            echo "Error: Git remote 'origin' is not configured"
            exit 1
          fi
          
          if ! git fetch origin; then
            echo "Error: Failed to fetch from origin"
            exit 1
          fi
          
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
          echo "Current branch: $CURRENT_BRANCH"
          
          if ! git diff-index --quiet HEAD -- 2>/dev/null; then
            echo "Warning: Working directory has uncommitted changes"
            git status --short
          fi
          
          if [ "$CURRENT_BRANCH" != "main" ]; then
            echo "Switching to main branch..."
            if ! git checkout -f main 2>/dev/null; then
              echo "Warning: Could not checkout main, trying to create tracking branch"
              git checkout -b main origin/main 2>/dev/null || {
                echo "Error: Failed to switch to main branch"
                exit 1
              }
            fi
          fi
          
          if ! git reset --hard origin/main; then
            echo "Error: Failed to reset to origin/main"
            echo "Current branch: $(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'unknown')"
            exit 1
          fi
          
          NEW_COMMIT=$(git rev-parse HEAD)
          echo "Updated to commit: $NEW_COMMIT"
          echo "new_commit=$NEW_COMMIT" >> $GITHUB_OUTPUT
          STEP_END=$(date +%s)
          echo "Code update completed in $((STEP_END - STEP_START))s"

      - name: Stop containers
        id: stop_containers
        working-directory: /opt/parseVK
        timeout-minutes: 5
        run: |
          STEP_START=$(date +%s)
          echo "=== Stopping containers ==="
          
          if ! docker compose down --timeout 30; then
            echo "Warning: docker compose down failed, forcing stop"
            docker compose kill || true
            docker compose down --remove-orphans || true
          fi
          
          MAX_WAIT=30
          WAIT_COUNT=0
          while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
            RUNNING=$(docker compose ps -q 2>/dev/null | wc -l)
            if [ "$RUNNING" -eq 0 ]; then
              echo "All containers stopped"
              break
            fi
            echo "Waiting for containers to stop... ($WAIT_COUNT/$MAX_WAIT)"
            sleep 1
            WAIT_COUNT=$((WAIT_COUNT + 1))
          done
          
          if [ "$RUNNING" -gt 0 ]; then
            echo "Warning: Some containers may still be running"
            docker compose ps
          fi
          
          STEP_END=$(date +%s)
          echo "Container stop completed in $((STEP_END - STEP_START))s"

      - name: Cleanup old images
        id: cleanup_images
        working-directory: /opt/parseVK
        timeout-minutes: 5
        run: |
          STEP_START=$(date +%s)
          echo "=== Cleaning up old images ==="
          
          docker compose down --rmi local --remove-orphans 2>/dev/null || true
          
          CURRENT_IMAGES=$(docker compose config --images 2>/dev/null || echo "")
          
          if [ -n "$CURRENT_IMAGES" ]; then
            docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "(parsevk|parseVK|postgres_db|redis)" | while read image; do
              if ! echo "$CURRENT_IMAGES" | grep -q "$image"; then
                echo "Removing unused image: $image"
                docker rmi "$image" 2>/dev/null || true
              fi
            done
          fi
          
          docker image prune -f --filter "dangling=true" || true
          STEP_END=$(date +%s)
          echo "Image cleanup completed in $((STEP_END - STEP_START))s"

      - name: Build containers
        id: build_containers
        working-directory: /opt/parseVK
        timeout-minutes: 25
        run: |
          STEP_START=$(date +%s)
          echo "=== Building containers ==="
          
          if ! docker compose build --parallel; then
            echo "Error: Build failed"
            docker compose build 2>&1 | tail -50
            exit 1
          fi
          
          echo "=== Built images ==="
          docker compose images
          STEP_END=$(date +%s)
          echo "Container build completed in $((STEP_END - STEP_START))s"

      - name: Start containers
        id: start_containers
        working-directory: /opt/parseVK
        timeout-minutes: 5
        run: |
          STEP_START=$(date +%s)
          echo "=== Starting containers ==="
          docker compose up -d
          
          echo "=== Container status ==="
          docker compose ps
          STEP_END=$(date +%s)
          echo "Container start completed in $((STEP_END - STEP_START))s"

      - name: Wait for services to be healthy
        id: wait_healthy
        working-directory: /opt/parseVK
        timeout-minutes: 5
        run: |
          STEP_START=$(date +%s)
          echo "=== Waiting for services to be healthy ==="
          
          if command -v docker > /dev/null 2>&1 && docker compose version > /dev/null 2>&1; then
            if docker compose wait --timeout 120 2>/dev/null; then
              echo "All services with healthchecks are healthy (via docker compose wait)"
            else
              echo "Warning: docker compose wait failed or timed out, falling back to manual check"
              
              MAX_ATTEMPTS=30
              ATTEMPT=0
              ALL_HEALTHY=false
              
              while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
                ATTEMPT=$((ATTEMPT + 1))
                echo "Attempt $ATTEMPT/$MAX_ATTEMPTS"
                
                UNHEALTHY_COUNT=0
                TOTAL_COUNT=0
                
                for container in $(docker compose ps -q); do
                  if [ -z "$container" ]; then
                    continue
                  fi
                  
                  TOTAL_COUNT=$((TOTAL_COUNT + 1))
                  STATUS=$(docker inspect --format='{{.State.Status}}' "$container" 2>/dev/null || echo "unknown")
                  HEALTH=$(docker inspect --format='{{.State.Health.Status}}' "$container" 2>/dev/null || echo "none")
                  NAME=$(docker inspect --format='{{.Name}}' "$container" 2>/dev/null | sed 's/^\///')
                  
                  if [ "$STATUS" = "running" ]; then
                    if [ "$HEALTH" = "healthy" ] || [ "$HEALTH" = "none" ]; then
                      echo "  $NAME: running ($HEALTH)"
                    else
                      echo "  $NAME: running ($HEALTH - waiting...)"
                      UNHEALTHY_COUNT=$((UNHEALTHY_COUNT + 1))
                    fi
                  else
                    echo "  $NAME: $STATUS (waiting...)"
                    UNHEALTHY_COUNT=$((UNHEALTHY_COUNT + 1))
                  fi
                done
                
                if [ $UNHEALTHY_COUNT -eq 0 ] && [ $TOTAL_COUNT -gt 0 ]; then
                  ALL_HEALTHY=true
                  break
                fi
                
                sleep 2
              done
              
              if [ "$ALL_HEALTHY" != "true" ]; then
                echo "Error: Not all containers are healthy"
                docker compose ps
                exit 1
              fi
            fi
          else
            echo "Error: Docker or docker compose not available"
            exit 1
          fi
          
          echo "All containers are healthy"
          STEP_END=$(date +%s)
          echo "Health wait completed in $((STEP_END - STEP_START))s"

      - name: Health check
        id: health_check
        working-directory: /opt/parseVK
        timeout-minutes: 3
        run: |
          STEP_START=$(date +%s)
          echo "=== Health Checks ==="
          
          if ! command -v curl > /dev/null 2>&1; then
            echo "Error: curl is not installed on the host"
            exit 1
          fi
          
          MAX_RETRIES=5
          RETRY_DELAY=3
          
          API_CONTAINER=$(docker compose ps -q api 2>/dev/null || echo "")
          FRONTEND_CONTAINER=$(docker compose ps -q frontend 2>/dev/null || echo "")
          
          check_api() {
            local retry=0
            while [ $retry -lt $MAX_RETRIES ]; do
              if [ -n "$API_CONTAINER" ]; then
                if docker exec "$API_CONTAINER" sh -c "command -v curl > /dev/null 2>&1 && curl -f -s -m 10 http://localhost:3000/api/health > /dev/null 2>&1 || wget -q -O- --timeout=10 http://localhost:3000/api/health > /dev/null 2>&1" 2>/dev/null; then
                  echo "✅ API health check passed (via container)"
                  return 0
                fi
              fi
              
              if curl -f -s -m 10 http://localhost:3000/api/health > /dev/null 2>&1; then
                echo "✅ API health check passed (via localhost)"
                return 0
              fi
              
              retry=$((retry + 1))
              if [ $retry -lt $MAX_RETRIES ]; then
                echo "⚠️ API health check failed, retry $retry/$MAX_RETRIES in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            done
            echo "❌ API health check failed after $MAX_RETRIES attempts"
            return 1
          }
          
          check_frontend() {
            local retry=0
            while [ $retry -lt $MAX_RETRIES ]; do
              if [ -n "$FRONTEND_CONTAINER" ]; then
                if docker exec "$FRONTEND_CONTAINER" sh -c "command -v curl > /dev/null 2>&1 && curl -f -s -m 10 http://localhost:80 > /dev/null 2>&1 || wget -q -O- --timeout=10 http://localhost:80 > /dev/null 2>&1" 2>/dev/null; then
                  echo "✅ Frontend health check passed (via container)"
                  return 0
                fi
              fi
              
              if curl -f -s -m 10 http://localhost:8080 > /dev/null 2>&1; then
                echo "✅ Frontend health check passed (via localhost)"
                return 0
              fi
              
              retry=$((retry + 1))
              if [ $retry -lt $MAX_RETRIES ]; then
                echo "⚠️ Frontend health check failed, retry $retry/$MAX_RETRIES in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
              fi
            done
            echo "❌ Frontend health check failed after $MAX_RETRIES attempts"
            return 1
          }
          
          API_OK=false
          FRONTEND_OK=false
          
          if check_api; then
            API_OK=true
          else
            echo "API health check failed. Container logs:"
            docker compose logs --tail=20 api 2>/dev/null || true
          fi
          
          if check_frontend; then
            FRONTEND_OK=true
          else
            echo "Frontend health check failed. Container logs:"
            docker compose logs --tail=20 frontend 2>/dev/null || true
          fi
          
          echo ""
          echo "=== Container logs (last 30 lines) ==="
          docker compose logs --tail=30
          
          if [ "$API_OK" != "true" ] || [ "$FRONTEND_OK" != "true" ]; then
            echo ""
            echo "=== Container status ==="
            docker compose ps
            echo ""
            echo "❌ Health checks failed"
            exit 1
          fi
          
          echo ""
          echo "✅ All health checks passed"
          STEP_END=$(date +%s)
          echo "Health check completed in $((STEP_END - STEP_START))s"

      - name: Rollback on failure
        if: failure()
        id: rollback
        working-directory: /opt/parseVK
        timeout-minutes: 15
        run: |
          STEP_START=$(date +%s)
          echo "=== Rolling back to previous version ==="
          
          PREVIOUS_COMMIT="${{ steps.save_version.outputs.current_commit }}"
          
          if [ "$PREVIOUS_COMMIT" != "unknown" ] && [ -n "$PREVIOUS_COMMIT" ] && [ "$PREVIOUS_COMMIT" != "HEAD" ]; then
            echo "Rolling back to commit: $PREVIOUS_COMMIT"
            
            if ! git fetch origin; then
              echo "Error: Failed to fetch from origin during rollback"
              exit 1
            fi
            
            if ! git checkout -f "$PREVIOUS_COMMIT"; then
              echo "Error: Failed to checkout previous commit $PREVIOUS_COMMIT"
              exit 1
            fi
            
            echo "=== Validating docker-compose.yml for rollback ==="
            if [ ! -f "docker-compose.yml" ]; then
              echo "Error: docker-compose.yml not found in previous commit"
              exit 1
            fi
            
            if ! docker compose config > /dev/null 2>&1; then
              echo "Error: Invalid docker-compose.yml in previous commit"
              docker compose config
              exit 1
            fi
            
            echo "=== Rebuilding and restarting ==="
            docker compose down --timeout 30 || true
            
            if ! docker compose build; then
              echo "Error: Build failed during rollback"
              docker compose build 2>&1 | tail -50
              exit 1
            fi
            
            if ! docker compose up -d; then
              echo "Error: Failed to start containers during rollback"
              docker compose ps
              exit 1
            fi
            
            echo "Waiting for services..."
            sleep 10
            
            echo "=== Checking rollback status ==="
            docker compose ps
            
            ROLLBACK_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
            echo "Rolled back to commit: $ROLLBACK_COMMIT"
          else
            echo "⚠️ Could not determine previous commit, skipping rollback"
            echo "Previous commit was: $PREVIOUS_COMMIT"
          fi
          STEP_END=$(date +%s)
          echo "Rollback completed in $((STEP_END - STEP_START))s"

      - name: Deployment status
        if: always()
        id: deployment_status
        run: |
          END_TIME=$(date +%s)
          START_TIME=${START_TIME:-$END_TIME}
          DURATION=$((END_TIME - START_TIME))
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment successful!"
            echo "Commit: $(cd /opt/parseVK && git rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
            echo "Total deployment time: ${DURATION}s"
          else
            echo "❌ Deployment failed!"
            echo "Total deployment time: ${DURATION}s"
          fi
