---
alwaysApply: true
---
# Архитектура фронтенд-проекта

## Структура проекта

```
src/
  pages/           # Страницы-роуты (только композиция модулей)
  components/       # Переиспользуемые UI-компоненты
    ui/           # Базовые UI компоненты (shadcn/ui)
    Sidebar/      # Группа компонентов сайдбара
  modules/         # Логически связанные фичи
    {module}/
      components/  # Компоненты модуля
      hooks/       # Хуки модуля
      config/      # Конфигурация (колонки таблиц, константы)
      utils/       # Утилиты модуля (если специфичны для модуля)
      types/       # Типы модуля (если специфичны для модуля)
      constants/   # Константы модуля (если специфичны для модуля)
  hooks/           # Общие кастомные хуки
  services/        # Работа с API, бизнес-логика
  store/           # Глобальное состояние (Zustand)
  utils/           # Общие утилиты, хелперы
  types/           # Общие типы и интерфейсы
  lib/             # Низкоуровневые вещи (конфиги, клиенты, провайдеры)
```

## Правила зависимостей

### Схема зависимостей

```
pages/
  ↓ может использовать
modules/, components/, hooks/, services/, store/, utils/, types/

modules/
  ↓ может использовать
components/, hooks/, services/, store/, utils/, types/

components/
  ↓ может использовать
hooks/, utils/, types/

services/
  ↓ может использовать
lib/, utils/, types/

store/
  ↓ может использовать
services/, utils/, types/

hooks/
  ↓ может использовать
store/, services/, utils/, types/

utils/
  ↓ может использовать
types/

types/
  ↓ не зависит ни от чего

lib/
  ↓ может использовать
types/
```

### Запрещённые зависимости

- ❌ `components/` → `modules/` (компоненты не знают о модулях)
- ❌ `components/` → `store/` (компоненты не зависят от store напрямую, только через хуки)
- ❌ `utils/` → `services/`, `store/`, `components/` (утилиты не зависят от бизнес-логики)
- ❌ `types/` → что-либо (типы независимы)
- ❌ `modules/` → `modules/` (модули изолированы друг от друга)
- ❌ `lib/` → `services/`, `store/`, `components/` (низкоуровневые вещи не зависят от верхних слоёв)

### Детальные правила

1. **pages/** — только композиция компонентов, минимум логики
   - Импортируют модули, компоненты, хуки
   - Используют store через хуки
   - Не содержат бизнес-логику

2. **modules/** — фичи с собственной логикой
   - Компоненты модуля используют хуки модуля
   - Хуки модуля используют store и services
   - Могут иметь собственные типы и утилиты

3. **components/** — переиспользуемые UI-компоненты
   - Не зависят от store напрямую
   - Получают данные через props
   - Могут использовать общие хуки и utils

4. **services/** — работа с API
   - Только HTTP-запросы и обработка ответов
   - Не содержат UI-логику
   - Могут использовать utils и lib

5. **store/** — глобальное состояние
   - Используют services для загрузки данных
   - Предоставляют API для компонентов
   - Могут использовать utils

6. **hooks/** — общие хуки
   - Могут использовать store, services, utils
   - Не содержат специфичную логику модулей

7. **utils/** — чистые функции
   - Не зависят от других слоев
   - Могут использовать только types

8. **lib/** — конфигурация
   - Настройки клиентов, провайдеров
   - Могут использовать types

9. **types/** — типы и интерфейсы
   - Никаких зависимостей

### Исключения

- Компоненты могут использовать store через кастомные хуки (например, `useTheme` в обертке)
- Модули могут напрямую использовать services для:
  - React Query queryFn (стандартный паттерн)
  - Одноразовых операций (импорт, экспорт, синхронизация), не требующих глобального состояния

## Стандарт структуры модуля

### Базовая структура

Каждый модуль должен иметь следующую структуру:

```
modules/{moduleName}/
  components/          # UI компоненты модуля
    ComponentName.tsx
  hooks/              # Хуки модуля
    useModuleQuery.ts
    useModuleViewModel.ts
  config/             # Конфигурация (опционально)
    tableColumns.tsx
    constants.ts
  utils/              # Утилиты модуля (опционально)
    formatData.ts
  types/              # Типы модуля (опционально)
    moduleTypes.ts
  constants/          # Константы модуля (опционально)
    moduleConstants.ts
```

### Когда использовать подпапки модуля

#### `components/` - всегда

Все UI компоненты, специфичные для модуля, должны находиться в `components/`.

**Примеры:**
- `modules/tasks/components/TasksHero.tsx`
- `modules/comments/components/CommentCard.tsx`
- `modules/watchlist/components/WatchlistTableCard.tsx`

#### `hooks/` - всегда

Все хуки, специфичные для модуля, должны находиться в `hooks/`.

**Примеры:**
- `modules/tasks/hooks/useTasksQuery.ts` - запросы данных
- `modules/comments/hooks/useCommentsViewModel.ts` - логика представления
- `modules/watchlist/hooks/useWatchlistAuthors.ts` - бизнес-логика модуля

#### `config/` - когда нужна конфигурация

Используйте `config/`, когда модулю нужна конфигурация, которая:
- Определяет структуру данных (колонки таблиц, поля форм)
- Содержит статические настройки отображения
- Используется только внутри модуля

**Примеры:**
- `modules/tasks/config/taskTableColumns.tsx` - определение колонок таблицы задач
- `modules/groups/config/groupTableColumns.tsx` - определение колонок таблицы групп
- `modules/comments/config/commentTableColumns.tsx` - определение колонок таблицы комментариев

**НЕ используйте `config/` для:**
- Констант, которые используются в нескольких модулях → `utils/` или `constants/` на верхнем уровне
- Типов → `types/` модуля или общие `types/`

#### `utils/` - когда утилиты специфичны для модуля

Используйте `utils/` внутри модуля, когда:
- Утилита используется **ТОЛЬКО** в этом модуле
- Утилита специфична для бизнес-логики модуля
- Утилита не может быть переиспользована в других модулях

**Примеры:**
- `modules/comments/utils/formatDateTime.ts` - форматирование даты для комментариев
- `modules/comments/utils/getAuthorInitials.ts` - получение инициалов автора для комментариев

**НЕ используйте `utils/` модуля для:**
- Утилит, которые используются в нескольких модулях → `utils/` на верхнем уровне
- Чистых функций без зависимости от модуля → `utils/` на верхнем уровне

#### `types/` - когда типы специфичны для модуля

Используйте `types/` внутри модуля, когда:
- Тип используется **ТОЛЬКО** в этом модуле
- Тип специфичен для внутренней структуры модуля
- Тип не должен быть доступен извне модуля

**Примеры:**
- `modules/comments/types/commentsTable.ts` - типы для внутренней структуры таблицы комментариев
- `modules/listings/types.ts` - типы для модуля listings

**НЕ используйте `types/` модуля для:**
- Типов, которые используются в нескольких модулях → `types/` на верхнем уровне
- DTO и API типов → `types/dto/` или `types/api/` на верхнем уровне
- Типов для store → `types/stores.ts` на верхнем уровне

#### `constants/` - когда константы специфичны для модуля

Используйте `constants/` внутри модуля, когда:
- Константы используются **ТОЛЬКО** в этом модуле
- Константы специфичны для бизнес-логики модуля

**Примеры:**
- `modules/watchlist/constants/watchlist.ts` - константы для watchlist модуля

**НЕ используйте `constants/` модуля для:**
- Констант, которые используются в нескольких модулях → общие константы на верхнем уровне

### Правило выбора места для файла

**Если файл используется только в одном модуле:**
- Компонент → `modules/{module}/components/`
- Хук → `modules/{module}/hooks/`
- Утилита → `modules/{module}/utils/` (если специфична) или `utils/` (если общая)
- Тип → `modules/{module}/types/` (если специфичен) или `types/` (если общий)
- Константа → `modules/{module}/constants/` (если специфична) или общие константы

**Если файл используется в нескольких модулях:**
- Компонент → `components/`
- Хук → `hooks/`
- Утилита → `utils/`
- Тип → `types/`
- Константа → общие константы

## Импорты

### Использование alias `@/`

Все импорты из общих слоёв должны использовать alias `@/`:

```typescript
// ✅ Правильно
import { Button } from '@/components/ui/button'
import { useTableSorting } from '@/hooks/useTableSorting'
import { tasksService } from '@/services/tasksService'
import type { Task } from '@/types'
import { formatDateTime } from '@/modules/comments/utils/formatDateTime'

// ❌ Неправильно
import { Button } from '../../../components/ui/button'
import { formatDateTime } from '../utils/formatDateTime'
```

### Внутримодульные импорты

**Все импорты внутри модулей должны использовать alias `@/`**, включая импорты между компонентами, хуками и другими частями модуля:

```typescript
// ✅ Правильно (через alias)
import { useModuleQuery } from '@/modules/moduleName/hooks/useModuleQuery'
import { MODULE_CONSTANTS } from '@/modules/moduleName/constants/moduleConstants'
import type { ModuleType } from '@/modules/moduleName/types/moduleTypes'
import { ComponentName } from '@/modules/moduleName/components/ComponentName'

// ❌ Неправильно (относительные импорты)
import { useModuleQuery } from '../hooks/useModuleQuery'
import { ComponentName } from './ComponentName'
```

**Преимущества использования alias:**
- Единообразие импортов по всему проекту
- Упрощение рефакторинга (перемещение файлов не ломает импорты)
- Лучшая читаемость (явный путь к модулю)
- Проще находить зависимости через поиск по проекту

**Примеры из проекта:**

```typescript
// modules/tasks/components/TaskDetails.tsx
import { useTaskDetails } from '@/modules/tasks/hooks/useTaskDetails'  // ✅

// modules/watchlist/hooks/useAuthorColumns.ts
import { AuthorCell } from '@/modules/watchlist/components/AuthorCell'  // ✅
import { PhotoAnalysisCell } from '@/modules/watchlist/components/PhotoAnalysisCell'  // ✅
```

## Разделение логики

### Компоненты

Компоненты должны содержать только UI-логику. Бизнес-логика выносится в хуки:

```typescript
// ✅ Правильно: логика в хуке
function CreateParseTaskModal({ isOpen, groups, ... }: Props) {
  const {
    selectedIds,
    search,
    setSearch,
    filteredGroups,
    handleToggle,
    handleSelectAll,
    handleDeselectAll,
  } = useCreateParseTaskModal(groups, isOpen)
  
  // только UI-логика
}

// ❌ Неправильно: логика в компоненте
function CreateParseTaskModal({ isOpen, groups, ... }: Props) {
  const [selectedIds, setSelectedIds] = useState(...)
  const [search, setSearch] = useState(...)
  // ... вся логика фильтрации здесь
}
```

### Хуки

Хуки модуля могут использовать:
- Store для получения и обновления состояния
- Services для работы с API (в React Query queryFn или для одноразовых операций)
- Utils для вспомогательных функций

## Работа с API

### React Query

Для работы с API используется React Query. Services используются напрямую в queryFn:

```typescript
// ✅ Правильно: services в queryFn
export const useTasksQuery = () => {
  const query = useQuery({
    queryKey: queryKeys.tasks,
    queryFn: tasksService.fetchTasks, // services используется здесь
    // ...
  })
  
  useEffect(() => {
    if (query.data) {
      useTasksStore.setState({ tasks: query.data }) // store обновляется здесь
    }
  }, [query.data])
  
  return query
}
```

### Одноразовые операции

Для одноразовых операций (импорт, экспорт, синхронизация) services могут использоваться напрямую:

```typescript
// ✅ Правильно: одноразовая операция
const handleImport = async () => {
  await listingsService.importFromJson({ file, source })
  onImportComplete()
}
```

## Глобальное состояние

Store используется для:
- Глобального состояния приложения
- Кэширования данных
- Синхронизации между компонентами

Компоненты не должны импортировать store напрямую. Вместо этого используются хуки:

```typescript
// ✅ Правильно: через хук
import { useTheme } from '@/hooks/useTheme'

function ThemeToggle() {
  const { isDarkMode, toggleTheme } = useTheme()
  // ...
}

// ❌ Неправильно: напрямую из store
import { useThemeStore } from '@/store'

function ThemeToggle() {
  const isDarkMode = useThemeStore((state) => state.isDarkMode)
  // ...
}
```

## Примеры модулей

### Модуль tasks

```
modules/tasks/
  components/
    TasksHero.tsx
    TasksList.tsx
    CreateParseTaskModal.tsx
    TaskDetails.tsx
  hooks/
    useTasksQuery.ts
    useTasksViewModel.ts
    useTasksSocket.ts
    useCreateParseTaskModal.ts
  config/
    taskTableColumns.tsx
    utils.ts
```

### Модуль comments

```
modules/comments/
  components/
    CommentCard.tsx
    CommentsTableCard.tsx
    CommentsHero.tsx
  hooks/
    useCommentsQuery.ts
    useCommentsViewModel.ts
  config/
    commentTableColumns.tsx
  utils/
    formatDateTime.ts
    getAuthorInitials.ts
  types/
    commentsTable.ts
```

### Модуль watchlist

```
modules/watchlist/
  components/
    WatchlistTableCard.tsx
    WatchlistHero.tsx
    WatchlistHeroErrorBoundary.tsx
  hooks/
    useWatchlistAuthors.ts
    useWatchlistQueries.ts
  constants/
    watchlist.ts
```

## Назначение слоёв

### pages/

Тонкие обёртки, которые:
- Импортируют компоненты из modules/
- Используют хуки из modules/ (viewModel hooks)
- Минимальная логика, только композиция

**Пример:**
```typescript
function Tasks() {
  const { tasks, fetchTasks } = useTasksViewModel()
  
  return (
    <div>
      <TasksHero />
      <TasksList tasks={tasks} />
    </div>
  )
}
```

### components/

Переиспользуемые UI-компоненты:
- Базовые UI (кнопки, карточки, таблицы) - `ui/`
- Общие компоненты (PageHeroCard, SearchInput, ProgressBar)
- НЕ содержат бизнес-логику
- НЕ зависят от конкретных модулей

### modules/

Доменные модули:
- Каждый модуль = одна фича/домен (tasks, groups, comments, watchlist и т.д.)
- Содержит компоненты, хуки, конфиги, специфичные утилиты и типы
- Модули изолированы друг от друга
- Могут использовать components/, hooks/, services/, store/, utils/, types/

### hooks/

Общие хуки:
- useIsMobile, useKeyboardNavigation, useTableSorting, useTheme, useSidebarData
- Используются в разных модулях

### services/

API и бизнес-логика:
- Один сервис = одна доменная область (tasksService, groupsService)
- Работают с API через lib/apiConfig, lib/apiUtils
- Могут использовать utils/, types/, lib/

### store/

Глобальное состояние:
- Zustand сторы для каждой доменной области
- Могут использовать services/, utils/, types/

### utils/

Общие утилиты:
- Чистые функции без зависимостей от React/бизнес-логики
- highlightKeywords, numberFormat, taskProgress и т.д.

### types/

Общие типы:
- DTO, API типы, общие интерфейсы
- Используются везде

### lib/

Низкоуровневые вещи:
- Конфиги (apiConfig, apiUtils)
- Провайдеры (QueryProvider, AppSyncProvider)
- queryClient

## Чек-лист для новых фич

При добавлении новой фичи:

1. ✅ Создать модуль в `modules/{moduleName}/`
2. ✅ Добавить компоненты в `modules/{moduleName}/components/`
3. ✅ Добавить хуки в `modules/{moduleName}/hooks/`
4. ✅ Использовать алиас `@/` для всех импортов (включая внутримодульные)
5. ✅ Вынести бизнес-логику из компонентов в хуки
6. ✅ Использовать store через хуки, а не напрямую
7. ✅ Использовать services в React Query queryFn или для одноразовых операций
8. ✅ Следовать правилам зависимостей между слоями

## Проверка соответствия архитектуре

### Аудит зависимостей

После изменений рекомендуется проверить соблюдение правил зависимостей:

1. **Компоненты не импортируют store напрямую**
   ```bash
   # Проверка: нет импортов store в компонентах модулей
   find modules -path "*/components/*" -name "*.tsx" | xargs grep -l "from '@/store'"
   ```

2. **Модули не импортируют друг друга**
   ```bash
   # Проверка: нет взаимных зависимостей между модулями
   # Все импорты должны быть внутри одного модуля
   ```

3. **Utils не импортируют services/store**
   ```bash
   # Проверка: utils остаются чистыми функциями
   find utils -name "*.ts" | xargs grep -l "from '@/\(services\|store\)'"
   ```

4. **Все импорты используют alias `@/`**
   ```bash
   # Проверка: нет относительных импортов
   find modules -name "*.tsx" -o -name "*.ts" | xargs grep "from '\.\./"
   ```

### Текущее состояние

✅ Все относительные импорты в модулях заменены на alias `@/`  
✅ Компоненты не импортируют store напрямую  
✅ Модули изолированы друг от друга  
✅ Utils не содержат зависимостей от services/store  
✅ Правила зависимостей соблюдаются

### Автоматическая проверка через ESLint

Настроены правила ESLint для автоматической проверки соблюдения архитектуры:

**Правила для компонентов модулей:**
- Запрет импорта `@/store` напрямую
- Компоненты должны использовать хуки модуля

**Правила для utils:**
- Запрет импорта `@/services` и `@/store`
- Utils должны оставаться чистыми функциями

**Запуск проверки:**
```bash
npm run lint
```

Правила настроены в `eslint.config.js` и используют встроенное правило `no-restricted-imports`.
