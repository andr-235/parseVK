# refactor

Упорядочить, переименовать и почистить код выбранного файла (не меняй API).

## Чеклист рефакторинга

### 1. Архитектурные правила

Проверь соблюдение архитектуры проекта:

- ✅ Использование alias `@/` вместо относительных путей
  - ❌ `import { Button } from '../../../components/ui/button'`
  - ✅ `import { Button } from '@/components/ui/button'`
  - См. `.cursor/rules/architecture.mdc` раздел "Импорты"

- ✅ Правильное размещение файлов в структуре модулей
  - Компоненты → `modules/{module}/components/`
  - Хуки → `modules/{module}/hooks/`
  - Утилиты → `modules/{module}/utils/` (если специфичны) или `utils/` (если общие)
  - См. `.cursor/rules/architecture.mdc` раздел "Стандарт структуры модуля"

- ✅ Соблюдение правил зависимостей между слоями
  - ❌ `components/` → `store/` (использовать через хуки)
  - ❌ `components/` → `modules/` (компоненты не знают о модулях)
  - ❌ `utils/` → `services/`, `store/`, `components/` (утилиты чистые)
  - ❌ `modules/` → `modules/` (модули изолированы)
  - См. `.cursor/rules/architecture.mdc` раздел "Правила зависимостей"

- ✅ Разделение логики по слоям
  - Компоненты содержат только UI-логику
  - Бизнес-логика в хуках модуля
  - API-логика в services
  - См. `.cursor/rules/architecture.mdc` раздел "Разделение логики"

### 2. Чистка кода

Удали весь ненужный код:

- ✅ Удаление неиспользуемых импортов
  - ❌ `import { useState, useEffect, useMemo } from 'react'` (если `useMemo` не используется)
  - ✅ `import { useState, useEffect } from 'react'`

- ✅ Удаление неиспользуемых переменных и функций
  - ❌ `const unusedVariable = someValue`
  - ❌ `function helper() { ... }` (нигде не вызывается)

- ✅ Удаление мертвого кода
  - Закомментированный код
  - Недостижимые ветки условий
  - Неиспользуемые типы и интерфейсы

- ✅ Устранение дублирования
  - Повторяющиеся блоки кода → вынести в функцию/хук
  - Похожие условия → объединить или вынести в утилиту
  - Дублирующиеся константы → вынести в общий файл

- ✅ Консолидация похожих блоков
  - Несколько похожих функций → параметризовать
  - Повторяющиеся паттерны → вынести в общий компонент/хук

### 3. Именование

Улучши читаемость через понятные имена:

- ✅ Описательные имена переменных
  - ❌ `const data = ...`, `const temp = ...`, `const x = ...`
  - ✅ `const taskList = ...`, `const filteredGroups = ...`, `const authorId = ...`

- ✅ Консистентность в именовании
  - Переменные и функции: `camelCase` (`handleClick`, `isLoading`)
  - Компоненты: `PascalCase` (`TaskCard`, `CreateModal`)
  - Константы: `UPPER_SNAKE_CASE` (`MAX_ITEMS`, `DEFAULT_POLL_INTERVAL`)
  - Типы/интерфейсы: `PascalCase` (`Task`, `AuthorData`)

- ✅ Префиксы для специальных сущностей
  - Хуки: `use` (`useTasksQuery`, `useTheme`)
  - Обработчики событий: `handle` (`handleSubmit`, `handleToggle`)
  - Булевы переменные: `is`, `has`, `can` (`isLoading`, `hasError`, `canEdit`)
  - Типы для props: `Props` или `ComponentNameProps` (`TaskCardProps`)

- ✅ Имена отражают назначение
  - Функции начинаются с глагола (`fetchTasks`, `calculateProgress`, `formatDate`)
  - Классы/типы — существительные (`TaskService`, `Author`)
  - Булевы — вопросы (`isActive`, `hasPermission`)

### 4. Читаемость

Сделай код понятнее:

- ✅ Разбиение длинных функций
  - Функции >50 строк → разбить на меньшие функции
  - Каждая функция решает одну задачу

- ✅ Извлечение сложной логики
  - Сложные условия → вынести в отдельную функцию с понятным именем
  - Многоуровневые вложенности → упростить через early returns
  - Магические числа → вынести в константы с описательными именами

- ✅ Группировка связанного кода
  - Импорты: внешние библиотеки → внутренние модули → типы
  - Переменные: состояние → вычисляемые значения → обработчики
  - Функции: публичные → приватные

- ✅ Удаление избыточных комментариев
  - ❌ `// Устанавливаем значение` перед `setValue(5)`
  - ✅ Комментарии только для неочевидной логики или бизнес-правил

- ✅ JSDoc для сложных функций
  - Публичные функции с неочевидной логикой
  - Функции с множеством параметров
  - Функции с побочными эффектами

### 5. Принципы проектирования (DRY, SOLID)

Примени принципы качественного кода:

- ✅ DRY (Don't Repeat Yourself)
  - Дублирующаяся логика → вынести в утилиту/хук
  - Похожие компоненты → параметризовать или создать базовый компонент
  - Повторяющиеся паттерны → абстрагировать

- ✅ Single Responsibility Principle
  - Одна функция/класс = одна задача
  - ❌ Функция, которая и валидирует, и сохраняет, и отправляет уведомление
  - ✅ Разделить на `validateData()`, `saveData()`, `sendNotification()`

- ✅ Open/Closed Principle
  - Код открыт для расширения, закрыт для модификации
  - Использовать композицию и параметризацию вместо изменения существующего кода

- ✅ Liskov Substitution Principle
  - Правильное использование наследования/типов
  - Подтипы должны быть взаимозаменяемы с базовыми типами

- ✅ Interface Segregation Principle
  - Не заставлять зависеть от неиспользуемых методов
  - Разделять большие интерфейсы на специализированные

- ✅ Dependency Inversion Principle
  - Зависимость от абстракций, не от конкретных реализаций
  - Использовать интерфейсы и dependency injection

### 6. Специфика проекта

Учти особенности проекта:

- ✅ Frontend (React/Vite)
  - Следование структуре модулей из `front/ARCHITECTURE.md`
  - Использование React Query для работы с API
  - Store через Zustand, доступ через хуки
  - См. `.cursor/rules/front-end.mdc` для деталей

- ✅ Backend (NestJS)
  - Модульная архитектура (один модуль = одна доменная область)
  - Использование DTO с class-validator для валидации
  - Сервисы содержат бизнес-логику
  - См. `.cursor/rules/back-end.mdc` для деталей

- ✅ Общие правила
  - TypeScript: явные типы, избегать `any`
  - Ранние возвраты для упрощения логики
  - Иммутабельность данных где возможно
  - Обработка ошибок через try/catch или глобальные обработчики

## Важно

- **НЕ меняй API** — сигнатуры функций, props компонентов, публичные методы
- **НЕ меняй бизнес-логику** — только структура и читаемость кода
- **НЕ добавляй новую функциональность** — только рефакторинг существующего кода
- **Сохраняй существующее форматирование** — отступы, стиль кода
- **Проверь линтер** — после рефакторинга код должен проходить проверки

