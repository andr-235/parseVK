# architect-backend

Ты — Senior backend разработчик. Твоя задача — навести порядок в архитектуре уже существующего backend-проекта на NestJS.

ВАЖНО:
- Проект уже существует и работает, но структура файлов и папок может быть хаотичной.
- Нельзя ломать всё и переписывать с нуля.
- НЕ ПРЕДЛАГАЙ архитектуру вида DDD / Clean Architecture / Onion Architecture с кучей абстракций.
- Нужна понятная, классическая, модульная архитектура NestJS.

ЦЕЛЕВАЯ ИДЕЯ:
Используем простую модульную архитектуру NestJS:

src/
  app.module.ts          # Главный модуль приложения
  main.ts                # Точка входа, bootstrap
  prisma.service.ts      # Prisma клиент (глобальный)
  {module}/              # Доменные модули
    {module}.module.ts        # Модуль NestJS
    {module}.controller.ts    # HTTP контроллер
    {module}.service.ts       # Бизнес-логика
    dto/                      # Data Transfer Objects (валидация входных данных)
    interfaces/               # Интерфейсы для абстракций
    repositories/             # Репозитории для работы с БД
    mappers/                  # Мапперы для преобразования данных
    builders/                 # Билдеры для построения запросов/объектов
    validators/               # Валидаторы бизнес-логики
    parsers/                  # Парсеры данных
    strategies/               # Стратегии (паттерн Strategy)
    services/                 # Дополнительные сервисы модуля
    queues/                   # Очереди BullMQ (если нужны)
    automation/               # Автоматизация (если нужна)
    types/                    # Типы модуля (если специфичны)
  common/                 # Общие модули и утилиты
    common.module.ts
    services/           # Общие сервисы (AuthorActivityService и т.п.)
    filters/            # Глобальные exception filters
    interceptors/       # Глобальные interceptors
    cache/              # Кэширование
    constants/          # Общие константы
    utils/              # Общие утилиты
    types/              # Общие типы
  vk/                     # Модуль интеграции с VK API
    vk.module.ts
    vk.service.ts
    interfaces/

ШАГ 1. АНАЛИЗ ТЕКУЩЕЙ СТРУКТУРЫ
1. Пройди по проекту и:
   - опиши текущую структуру папок и файлов в `api/src/`;
   - покажи, где:
     • контроллеры содержат бизнес-логику вместо сервисов;
     • сервисы напрямую используют Prisma вместо репозиториев;
     • отсутствуют DTO для валидации входных данных;
     • отсутствуют мапперы для преобразования данных;
     • отсутствуют репозитории для инкапсуляции работы с БД;
     • бизнес-логика смешана с инфраструктурой;
     • есть дублирующийся код и "god services" (слишком большие сервисы);
     • отсутствуют интерфейсы для абстракций;
     • файлы лежат не в тех папках (например, DTO в корне модуля вместо dto/).
2. Сформулируй кратко:
   - какие основные проблемы сейчас у архитектуры;
   - какие узкие места будут мешать развитию проекта;
   - какие модули нарушают правила зависимостей.

ШАГ 2. ПРЕДЛОЖИ ЦЕЛЕВУЮ МОДУЛЬНУЮ АРХИТЕКТУРУ
1. Предложи итоговую структуру папок на основе схемы выше (согласно `api/ARCHITECTURE.md`).
2. Для каждой папки:
   - объясни, за что она отвечает;
   - приведи примеры файлов, которые туда должны переехать из текущего проекта.
3. Покажи, какие модули должны быть созданы/реорганизованы:
   - простые модули (Groups, Keywords) — минимальная структура;
   - средние модули (Comments, Watchlist) — с репозиториями, мапперами, билдерами;
   - сложные модули (Tasks) — с очередями, gateway, automation.

ШАГ 3. КАРТА МИГРАЦИИ (OLD → NEW)
Сделай понятную таблицу/список:
- какие текущие файлы/папки нужно:
  • переименовать,
  • перенести,
  • разбить на части.
Пример формата:
- `api/src/groups/groups.service.ts` (с Prisma запросами) → вынести в `repositories/groups.repository.ts`
- `api/src/comments/comments.controller.ts` (с бизнес-логикой) → перенести логику в `comments.service.ts`
- `api/src/tasks/tasks.service.ts` (слишком большой) → разбить на `tasks.service.ts` + `services/task-runner.service.ts`
- `api/src/{module}/*.dto.ts` (в корне) → перенести в `dto/`
- `api/src/{module}/types.ts` → перенести в `types/` или `interfaces/`

ШАГ 4. ПРАВИЛА ЗАВИСИМОСТЕЙ
Определи простые правила на основе `api/ARCHITECTURE.md`:
- `{module}.controller.ts` может использовать только `{module}.service.ts`, `dto/`, `interfaces/`.
- `{module}.service.ts` может использовать `repositories/`, `mappers/`, `builders/`, `validators/`, `parsers/`, `strategies/`, `services/`, `common/`, `vk/`.
- `repositories/` может использовать только `prisma.service.ts`, `mappers/`, `interfaces/`.
- `mappers/` может использовать только `dto/`, `types/`, `interfaces/`.
- `builders/` может использовать только `types/`, `interfaces/`.
- `validators/` может использовать только `dto/`, `types/`, `interfaces/`.
- `parsers/` может использовать только `types/`, `interfaces/`.
- `strategies/` может использовать только `interfaces/`, `types/`.
- `services/` (внутри модуля) может использовать `repositories/`, `mappers/`, `common/`, `vk/`, `types/`.
- `queues/` может использовать `services/`, `repositories/`, `common/`, `vk/`.
- `common/` может использовать `vk/`, `prisma.service.ts`, `types/`.
- `vk/` может использовать только `interfaces/`, `types/`.
- `types/` не зависит ни от чего.

Сформулируй это как набор коротких правил + текстовую схему зависимостей.

ШАГ 5. ПЛАН РЕФАКТОРИНГА ПО ЭТАПАМ
Разбей работу на этапы, чтобы можно было постепенно всё привести в порядок, не ломая прод:

Пример:
- Этап 1: Навести порядок в структуре модулей (создать папки dto/, repositories/, mappers/ и т.п.).
- Этап 2: Вынести Prisma запросы из сервисов в репозитории.
- Этап 3: Вынести бизнес-логику из контроллеров в сервисы.
- Этап 4: Создать DTO для всех входных данных и добавить валидацию через class-validator.
- Этап 5: Создать мапперы для преобразования Prisma моделей в DTO.
- Этап 6: Разбить большие сервисы на меньшие компоненты (builders, validators, parsers, strategies).
- Этап 7: Создать интерфейсы для репозиториев и стратегий (dependency injection).
- Этап 8: Настроить правильные зависимости между слоями (убрать нарушения).

Для каждого этапа:
- опиши конкретные действия;
- добавь критерии "когда этап считается завершённым";
- укажи, какие модули можно рефакторить параллельно.

ШАГ 6. ПРИМЕРЫ КОНКРЕТНЫХ ИЗМЕНЕНИЙ
На основе кода:
- выбери 1–2 показательных модуля (контроллер + сервис + работа с БД);
- покажи, как они должны выглядеть в новой архитектуре:
  • новые пути файлов;
  • обновлённые импорты;
  • разделение контроллер / сервис / репозиторий / маппер;
  • использование DTO для валидации;
  • использование интерфейсов для абстракций.

Пример "было → стало":
- Было: `groups.service.ts` с прямыми Prisma запросами
- Стало: `groups.service.ts` → использует `repositories/groups.repository.ts` → использует Prisma

ОБЩИЕ ПРАВИЛА:
- НЕ предлагай DDD, Clean Architecture, Onion Architecture с кучей абстракций.
- Сохраняй весь текущий функционал.
- Все изменения должны быть реалистичны для постепенного внедрения.
- Следуй принципам из `api/ARCHITECTURE.md`.
- Используй паттерны NestJS: модули, dependency injection, декораторы.
- В ответе сначала сделай:
  1) диагноз текущей архитектуры,
  2) целевую структуру,
  3) план миграции по шагам,
  4) 1–2 конкретных примера "было → стало".

